#include <ESP8266WiFi.h>
#include <WiFiUDP.h>
#include <ESP8266mDNS.h>
#include <ESP8266WebServer.h>
#include <ESP8266HTTPUpdateServer.h>
#include <PubSubClient.h>
#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>


// Global constants for WiFi connections
// ***********************************
// Need to replace with WiFiManager
// ***********************************

// Network setup
const char* ssid = "Xegony";              // your network SSID (name)
const char* pass = "Klumpert!23456";        // your network password
const char* hostname = "openWB-Display";      

// MQTT Setup
IPAddress MQTT_Broker(192,168,10,140); // openWB IP address
const int MQTT_Broker_Port = 1883;

// MQTT topics and variables for retrieved values
const char* MQTT_EVU_W = "openWB/evu/W";    // current power at EVU
int EVU_W = 0;

const char* MQTT_PV_W = "openWB/pv/W";      // current PV power
int PV_W = 0;

const char* MQTT_LP_all_W= "openWB/global/WAllChargePoints";  // current power draw for all charge points
int LP_all_W = 0;

const char* MQTT_LP1_SOC= "openWB/lp/1/%Soc";  // current power draw for all charge points
int LP1_SOC = 0;

const char* MQTT_LP1_PlugStat = "openWB/lp/1/boolPlugStat"; // is the car plugged in?
bool LP1_PlugStat = false;

const char* MQTT_LP1_IsCharging = "openWB/lp/1/boolChargeStat"; // charging active?
bool LP1_IsCharging = false;


// Display Setup
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 64 // OLED display height, in pixels

// Declaration for an SSD1306 display connected to I2C (SDA, SCL pins)
#define OLED_RESET     0 // Reset pin # (or -1 if sharing Arduino reset pin)
Adafruit_SSD1306 display(SCREEN_WIDTH, SCREEN_HEIGHT, &Wire, OLED_RESET);

unsigned long currentMillis;
unsigned long previousMillis = 0;         // last time data was fetched
unsigned long lastMQTTDataReceived = 0;
int MaxDataAge = 30*1000; // max wait time for new data from MQTT subscription

WiFiClient espClient;
PubSubClient MQTTClient(espClient);
long lastReconnectAttempt = 0; // WiFi Reconnection timer

// Config flags do enable features
const bool isDebug = 1;                        // Send debug messages to serial port?

// ESP8266 Webserver and update server
ESP8266WebServer server(80);              // HTTP server port
ESP8266HTTPUpdateServer httpUpdater;      // HTTP update server, allows OTA flash by navigating to http://<ESP8266IP>/update

void WriteLog(String msg,bool NewLine=1)  // helper function for logging, only write to serial if isDebug is true
{
  if(NewLine)
  {
    if(isDebug){Serial.println(msg);}
  }
  else
  {
    if(isDebug){Serial.print(msg);}
  } 
}

boolean MQTTReconnect() 
{
  if (MQTTClient.connect(hostname)) 
  {
    WriteLog("MQTT Reconnected");
    boolean r = MQTTClient.subscribe(MQTT_EVU_W);
    if (r)
    {
        WriteLog("MQTT subscription suceeded");
    }
    else
    {
        WriteLog("MQTT subscription failed");
    }
    
    r = MQTTClient.subscribe(MQTT_LP_all_W);
    r = MQTTClient.subscribe(MQTT_PV_W);
    r = MQTTClient.subscribe(MQTT_LP1_SOC);
    r = MQTTClient.subscribe(MQTT_LP1_IsCharging);
    r = MQTTClient.subscribe(MQTT_LP1_PlugStat);
  }
  return MQTTClient.connected();
}

void HandleRoot()                                                 // Handle Webserver request on root
{
  String res = "HTTP Server up and running.";
  WebserverResponse(res);
}

void HandleMQTTStatus()
{
  String res = String(MQTTClient.state());
  WebserverResponse(res);
}

void WebserverResponse(String str)
{ 
    str.trim();
    WriteLog("Sending WebServer response, requested URI: " + server.uri());
    server.sendHeader("Cache-Control", "no-cache");
    server.send(200, "text/plain",String(str));
    WriteLog("Sending HTTP response: " + str);
}

void MQTTCallback(char* topic, byte* payload, unsigned int length) 
{
  lastMQTTDataReceived = millis();
  WriteLog("Message arrived: [" ,0);
  WriteLog(topic ,0);
  WriteLog("]" ,0);
  String msg;
  for (int i=0;i<length;i++) { // extract payload
    msg = msg + (char)payload[i];
  }
  WriteLog(msg);
  
  // store values in variables
  // todo use MQTT_ constants instead of hard coded values to compare
  if (strcmp(topic,"openWB/evu/W")==0){EVU_W = (msg.toInt());}
  if (strcmp(topic,"openWB/pv/W")==0){PV_W = (msg.toInt()*-1);}
  if (strcmp(topic,"openWB/global/WAllChargePoints")==0){LP_all_W = msg.toInt();}
  if (strcmp(topic,"openWB/lp/1/%Soc")==0){LP1_SOC = msg.toInt();}
  if (strcmp(topic,"openWB/lp/1/boolChargeStat")==0){LP1_IsCharging = msg.toInt();}
  if (strcmp(topic,"openWB/lp/1/boolPlugStat")==0){LP1_PlugStat = msg.toInt();}
  
  // processed incoming message, lets update the display
  UpdateDisplay();
}

void WriteDisplayNewText(String msg)
{
  display.clearDisplay();
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.setCursor(0,0);
  WriteDisplayText(msg);
}

void WriteDisplayText(String msg)
{
  display.println(msg);
  display.display();
}

void WriteWattValue(int Watt, int x, int y)
{
  int shift_k_value = 3;
  int shift_dot = 1;
  // check if Watt Value is smaller than 1000 (=1kW)
  if (Watt < 1000)
  {
	// value is smaller than 1kW, 
	// need to write value right-aligned
    if (Watt < 10)
    {
      display.setCursor(x-1*12, y);
      display.println("    "+String(Watt));
    }
    else if (Watt < 100)
    {
      display.setCursor(x-2*12, y);
      display.println("   "+String(Watt));
    }
    else
    {
      display.setCursor(x-3*12, y);
      display.println("  "+String(Watt));
    }
  }
  else
  {
    if (Watt < 10000)
    {
      int D_Watt_kW=Watt/1000;
      int D_Watt_W=Watt-D_Watt_kW*1000;
      if (D_Watt_W <10)
      {
        display.setCursor(x-3*12, y);
        display.print("00"+String(D_Watt_W));
        display.setCursor(x-4*12+shift_dot, y);
        display.print(".");
        display.setCursor(x-5*12+shift_k_value+shift_dot, y);
        display.print(String(D_Watt_kW));
      }
      else if (D_Watt_W < 100)
      {
        display.setCursor(x-3*12, y);
        display.print("0"+String(D_Watt_W));
        display.setCursor(x-4*12+shift_dot, y);
        display.print(".");
        display.setCursor(x-5*12+shift_k_value+shift_dot, y);
        display.print(String(D_Watt_kW));
      }
      else
      {
        display.setCursor(x-3*12, y);
        display.print(String(D_Watt_W));
        display.setCursor(x-4*12+shift_dot, y);
        display.print(".");
        display.setCursor(x-5*12+shift_k_value+shift_dot, y);
        display.print(String(D_Watt_kW));
      }
    }
    else
    {
      int D_Watt_kW=Watt/1000;
      int D_Watt_W=Watt-D_Watt_kW*1000;
      if (D_Watt_W <100)
      {
        display.setCursor(x-3*12, y);
        display.print("0"+String(D_Watt_W/10));
        display.setCursor(x-4*12+shift_dot, y);
        display.print(".");
        display.setCursor(x-5*12+shift_k_value+shift_dot, y);
        display.print(String(D_Watt_kW));
      }
      else
      {
        display.setCursor(x-3*12, y);
        display.print(String(D_Watt_W/10));
        display.setCursor(x-4*12+shift_dot, y);
        display.print(".");
        display.setCursor(x-5*12+shift_k_value+shift_dot, y);
        display.print(String(D_Watt_kW));
      }
    }
  }
}

void UpdateDisplay()
{
  // for a 128*64px display:
  // Text Size 1: single char 6*8px, 21 chars per row, 8 rows 
  // Text Size 2: single char 12*16px, 10 chars per row, 4 rows 
  // Text Size 3: single char 18*24x, 7 chars per row, 2.5 rows 
  // Text Size 4: single char 24*32x, 5 chars per row, 2 rows 
  // Text Size 8: single char 48*64x, 2 chars per row, 1 row 
  
  display.clearDisplay();
  display.setCursor(0,0); //set upper left corner of cursor to upper left corner of display
  
  String ChargeStatus="";
  if(LP1_IsCharging)
  {
    ChargeStatus = "  C";
  }
  else if(LP1_PlugStat==true)
  {
    ChargeStatus="  P";
  }
  else
  {
    ChargeStatus="  x  ";
  }
  

  // check if EVU power is smaller than 1 kW
  if (EVU_W < 1000)
  {
    // display description and value in W
    display.setTextSize(1);
    display.setCursor(SCREEN_WIDTH/2-8*6,0); // Text size 1 has width of 6
    display.println(" EVU (W)");
    display.setTextSize(2);
    display.setCursor(SCREEN_WIDTH/2-5*12,10); // Text size 1 has width of 12
    if (EVU_W < 10)
    {
      display.println("    "+String(EVU_W));
    }
    else if (EVU_W < 100)
    {
      display.println("   "+String(EVU_W));
    }
    else
    {
      display.println("  "+String(EVU_W));
    }
  }
  else
  {
    // display description and value in kW
    display.setTextSize(1);
    display.setCursor(SCREEN_WIDTH/2-8*6,0); // Text size 1 has width of 6
    display.println("EVU (kW)");
    display.setTextSize(2);
    display.setCursor(SCREEN_WIDTH/2-5*12,10); // Text size 1 has width of 12
    // write to display depending on the value
    // there are 5 characters available
    // 1.234 or 12.34
    if (EVU_W < 10000)
    {
      int D_EVU_kW=EVU_W/1000;
      int D_EVU_W=EVU_W-D_EVU_kW*1000;
      if (D_EVU_W <10)
      {
        display.print(String(D_EVU_kW)+".00"+String(D_EVU_W));
      }
      else if (D_EVU_W < 100)
      {
        display.print(String(D_EVU_kW)+".0"+String(D_EVU_W));
      }
      else
      {
        display.print(String(D_EVU_kW)+"."+String(D_EVU_W));
      }
    }
    else
    {
      display.print(String(EVU_W/1000)+"."+String(EVU_W/10-EVU_W/100));
    }
  }

  // check if PV power is smaller than 1 kW
  display.setTextSize(1);
  display.setCursor(SCREEN_WIDTH-7*6,0); // Text size 1 has width of 6
  if (PV_W < 1000)
  {
    // display description and value in W
    display.println(" PV (W)");
  }
  else
  {
    display.println("PV (kW)");
  }
  display.setTextSize(2);
  //display.setCursor(SCREEN_WIDTH-5*12,10); // Text size 1 has width of 12
  //WriteWattValue(PV_W);
  WriteWattValue(3567, SCREEN_WIDTH, 10);
  /*
  display.setTextSize(1);
  display.setCursor(0,32); //continue in the middle of the screen
  //display.println("All LP     SoC LP1"+ChargeStatus);
  display.println("All LP   "+ChargeStatus+"SoC LP1");
  display.setTextSize(2);
  display.print(LP_all_W);
  display.setCursor(13*6,32+8); //11 chars a 6px right, one 8px row below half of the display height (32px)
  String LP1_SOC_string="";
  if (LP1_SOC < 10)
  {
    LP1_SOC_string = "  "+String(LP1_SOC);
  }
  else if (LP1_SOC < 100)
  {
    LP1_SOC_string = " "+String(LP1_SOC);
  }
  else LP1_SOC_string = String(LP1_SOC);
  display.print(LP1_SOC_string + "%");
  */
  display.display();

}

// ------------------------------------------------
//   SETUP running once at the beginning
// ------------------------------------------------
//   Initialize  Serial, WiFi and Siplay

void setup() 
{
  Serial.begin(115200);

  while (!Serial) { // wait for serial port to connect. 
    ; 
  }
  WriteLog("openWB Display Init");
  
  if(!display.begin(SSD1306_SWITCHCAPVCC, 0x3C)) { // Address 0x3D for 128x64
  Serial.println(F("SSD1306 allocation failed"));
  for(;;); // Don't proceed, loop forever
  }
  display.display();
  
  // Clear the buffer
  display.clearDisplay();
  
  WriteLog("Waiting for WiFi connection");
  WriteDisplayNewText("Connecting to WiFi");
  WiFi.mode(WIFI_STA);                             // connect to AP
  WiFi.begin(ssid, pass);                          // set WiFi connections params
  WiFi.hostname(hostname);
 
  // Connecting
  int timout = 0;
  while (WiFi.status() != WL_CONNECTED)
  {
    delay(500);
    WriteLog("O",0);
    display.setTextSize(1);
    display.print("O");
    display.display();
    timout++;
    if  (timout > 20)                 // couldn'T connect to WiFi within timeout. No WiFi. Need to add better handling
    {
      WriteLog("");
      WriteLog("Not Connected to WiFi");
      WriteDisplayNewText("Error connecting to WiFi. Exiting.");
      break;
    }
  }
 
  if (WiFi.status() == WL_CONNECTED)
  {
    WriteLog("");
    WriteLog("Connected to WiFi:");
    Serial.println(WiFi.localIP());
  }

  MDNS.begin(hostname);               // Start mDNS 
  server.on("/", HandleRoot);         // Call function if root is called
  
  httpUpdater.setup(&server);         // Updater
  server.begin();                     // start HTTP server
  WriteLog("HTTP server started");
   
  MQTTClient.setServer(MQTT_Broker,MQTT_Broker_Port);
  MQTTClient.setCallback(MQTTCallback);
  lastReconnectAttempt = 0;
  MQTTReconnect;
  
  WriteLog("Exiting Setup, starting main loop");
  UpdateDisplay();
}

// ------------------------------------------------
//   MAIN LOOP RUNNING all the time
// ------------------------------------------------
void loop() 
{
  if (!MQTTClient.connected())      // non blocking MQTT reconnect sequence
    {
        long now = millis();
        if (now - lastReconnectAttempt > 5000) 
        {
          lastReconnectAttempt = now;
          WriteLog("Attempting to reconnect MQTT");
          if (MQTTReconnect()) 
          {
              lastReconnectAttempt = 0;
          }
        }
    }
    else                            // MQTT is connected, lets send some data
    { 
        // do things
    }
  if (millis()-lastMQTTDataReceived > MaxDataAge)
  {
    display.clearDisplay();
    display.setTextSize(3);
    display.setCursor(0,0);
    display.println("Error");
    display.println("no data");
    display.display();
  }

  MQTTClient.loop();                    // handle MQTT client & subscription. Display logic is subscription event triggered and can be found in the callback function.
  server.handleClient();                // handle webserver requests
  MDNS.update();                        // handle mDNS requests
}
